#!/usr/bin/tclsh
# Copyright (c) 2015 Jeremy Dilatush
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY JEREMY DILATUSH AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL JEREMY DILATUSH OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# Convert 6502 program ROM contents from Motorola SREC format (generated by
# the "crasm" assembler) to the format taken by $readmemh() in Verilog, in
# particular the very limited variant of that format which Xilinx's
# XST documentation describes.

# As it currently stands this program only handles byte data (ie 8 bits wide).

proc usage {} {
    puts stderr "Usage: tclsh srec2memh.tcl \[options\] < input > output"
    puts stderr "Options:"
    puts stderr "\tsz= memory size in bytes, default 256"
    puts stderr "\tof= offset, address of start of memory, default 0"
    puts stderr "\tfi= byte value to fill uninitialized entries with, def 0"
    puts stderr "\tcm=1 output a comment violating the specification, def 0"
    exit 1
}

# read command line parameters into array $parm()
set parm(sz) 256
set parm(of) 0
set parm(fi) 0
set parm(cm) 0

foreach arg $argv {
    set ap [split $arg =]
    set ap0 [lindex $ap 0]
    set ap1 [lindex $ap 1]
    if {[llength $ap] != 2 ||
        ![string is integer -strict $ap1] ||
        ![info exists parm($ap0)]} {
        puts stderr "Invalid parameter $arg"
        usage
    }
    set parm($ap0) $ap1
}

# initialize an internal model of the memory, $rom()
# and a record of how many times each word was written, $ovr()
for {set i 0} {$i < $parm(sz)} {incr i} {
    set rom($i) $parm(fi)
    set ovr($i) 0
}

# parse1 - pass 1 of parsing an S-Record.  Breaks it into pieces, returned
# in a list:
#       type (including "S")
#       address
#       data
# it validates the checksum & doesn't return it.  The address value it
# returns is a single numeric value; the data value it returns is a
# list of numeric byte values.
#
# Returns empty list on recoverable parse error or a type of record that
# is ignored.
proc parse1 {sr} {
    set l [string length $sr]
    if {$l < 2} {
        error "Record is truncated in its type field"
    }
    set type [string range $sr 0 1]
    if {$l < 4} {
        error "$type record is truncated in its record length field"
    }
    set reclen [scan [string range $sr 2 3] %x]
    switch -- $type {
        S0 { set alen 4 }
        S1 { set alen 4 }
        S2 { set alen 6 }
        S3 { set alen 8 }
        S5 { set alen 4 }
        S6 { set alen 6 }
        S7 { set alen 8 }
        S8 { set alen 6 }
        S9 { set alen 4 }
        default { return [list] }
    }
    if {$l < $alen + 4} {
        error "$type record is truncated in its address part"
    }
    set addr [scan [string range $sr 4 $alen+3] %x]
    set reclend [expr {$reclen * 2 + 4}]
    if {$l != $reclen * 2 + 4} {
        error \
            "$type record has wrong length, encoded $reclend ($reclen) real $l"
    }

    set cksum [scan [string range $sr end-1 end] %x]
    set cksum2 0
    for {set i 2} {$i < $l - 2} {incr i 2} {
        set byte [scan [string range $sr $i $i+1] %x]
        set cksum2 [expr {($cksum2 + $byte) & 255}]
    }
    set cksum2 [expr {$cksum2 ^ 255}]
    if {$cksum != $cksum2} {
        error "$type record bad checksum, got $cksum exp $cksum2"
    }

    set data [list]
    for {set i [expr {$alen + 4}]} {$i < ($l - 2)} {incr i 2} {
        lappend data [scan [string range $sr $i $i+1] %x]
    }

    return [list $type $addr $data]
}

# read the file line by line
set lc_blank 0 ; # skipped lines: blank
set lc_nons 0 ; # skipped lines: no "S"
set lc_parse 0 ; # skipped lines: basic parse error, or unknown type
set lc_nop 0 ; # skipped lines: a type we do nothing with
set lc_use 0 ; # lines not skipped
while {![eof stdin]} {
    # get a line
    set line [string trim [gets stdin]]
    if {$line eq ""} {
        # skip this line
        incr lc_blank
        continue
    }
    if {[string index $line 0] ne "S"} {
        # skip this line
        incr lc_nons
        continue
    }

    # parse it
    set pl [parse1 $line]

    if {![llength $pl]} {
        # skip this line
        incr lc_parse
        continue
    }

    lassign $pl Type Addr Data

    # handle it
    switch -- $Type {
        S1 -
        S2 -
        S3 {
            # Data record
            set l [llength $Data]
            if {$Addr + $l > $parm(sz) + $parm(of) || $Addr < $parm(of)} {
                error "Address out of range: Record addr $Addr len $l"
            }
            for {set i 0} {$i < $l} {incr i} {
                set ma [expr {$Addr + $i - $parm(of)}]
                set rom($ma) [lindex $Data $i]
                incr ovr($ma)
            }
            incr lc_use
        }
        default {
            # skip this line
            incr lc_nop
            continue
        }
    }
}

# Print a report on what we did
set bf 0
set bu 0
set bo 0
for {set i 0} {$i < $parm(sz)} {incr i} {
    switch -- $ovr($i) {
        0 { incr bu }
        1 { incr bf }
        default { incr bf ; incr bo }
    }
}
foreach {rl rv} [list \
    "Skipped lines (blank)" $lc_blank \
    "Skipped lines (not 'S')" $lc_nons \
    "Skipped lines (parse/type)" $lc_parse \
    "Skipped lines (ignored)" $lc_nop \
    "Used lines" $lc_use \
    "Bytes filled" $bf \
    "Bytes unfilled" $bu \
    "Bytes overwritten" $bo \
] {
    puts stderr [format {srec2memh:%27s %s} $rl $rv]
}

# Now write the output.
for {set i 0} {$i < $parm(sz)} {incr i} {
    set l [format %02x $rom($i)]
    if {$parm(cm)} {
        if {$i == 0} {
            append l [format { // Converted by srec2memh, %s} \
                [clock format [clock seconds]]]
        } elseif {!($i & 15)} {
            append l [format { // Address %d (0x%x)} $i $i]
        }
    }
    puts $l
}

