2015/Apr/14

an idea for a bootloading protocol, a way to load programs onto the 
VTJ-1 device at boot time.  Potentially useful during development.

It uses the serial port over FTDI, in 8n1 (or 8n2), at one of three
speeds:
    slow - 1200 baud
    medium - 9600 baud
    high - 115,200 baud

On reset, it cycles through those three speeds.  It also indicates the
speed on three of the LEDs:
    slow = on/off/off
    medium = on/on/off
    high = on/off/on

The protocol from host to target consists of 4 byte commands.  The first
byte has its high bit set, the others have it cleared.
    byte 0 - contains various bits
        &$80 - is 1
        &$40 - supplies high bit for byte 1
        &$20 - supplies high bit for byte 2
        &$10 - supplies high bit for byte 3
        &$0f - check code; the numeric value of the 4 byte command,
            modulo 15, should be 9 (byte ordering doesn't even matter
            for computing it)
    byte 1 - low byte of the address
    byte 2 - high byte of the address
    byte 3 - value to write

For each command, the target sends one byte back to the host.  It
contains a check code, after updating the check code with this command.
The check code is a one byte value updated as follows with each
byte of each command:
    add the command byte, ones complement
    rotate right, one bit

A few addresses are handled specially or have special significance:
    $fe, $ff - these form a pointer to some code
    $fd - when $42 is written to this byte, the bootloader will
        jump to the code pointed to by $fe, $ff.
        Other values are reserved for special commands; don't use.
        Will initially be $00 which means, default behavior.
        The code jumped to will be run with interrupts disabled.
    $00 - $ff - zero page addresses are in general reserved
    ? - $ffff - bootloader's own code; don't modify this or bad
        things may happen. In the future I might change this to
        redirect writes to a copy of the bootloader's code, which will
        be copied back when it's time to execute (from a separate
        chunk of code, in turn copied into a temporary buffer)
        but I may not need to and for now I won't bother.
    $200-$2ff -- used as a lookup table for check code computation

This is not terribly efficient but it should be fast enough.

The host side program will issue commands and collect the check codes.
If the check code mismatches, it'll reset its own copy of the check code,
then go back to the last acknowledged command.  There may be more than
one command "in flight" - a compromise between speed (there's some latency
in passing serial data in my setup) and buffer size limits.

The host side program will first write the program code; then write
the start address to $0 and $1; then write the command $42 to $02.
Those last parts will probably be done in a slower, more cautious way
of checking every command's result.

